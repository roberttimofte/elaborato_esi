function varargout = layout(varargin)
% LAYOUT MATLAB code for layout.fig
%      LAYOUT, by itself, creates a new LAYOUT or raises the existing
%      singleton*.
%
%      H = LAYOUT returns the handle to a new LAYOUT or the handle to
%      the existing singleton*.
%
%      LAYOUT('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in LAYOUT.M with the given input arguments.
%
%      LAYOUT('Property','Value',...) creates a new LAYOUT or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before layout_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to layout_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help layout

% Last Modified by GUIDE v2.5 07-Mar-2021 10:01:53

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @layout_OpeningFcn, ...
                   'gui_OutputFcn',  @layout_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before layout is made visible.
function layout_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to layout (see VARARGIN)

% Choose default command line output for layout
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes layout wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = layout_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes on button press in analizzabutton.
function analizzabutton_Callback(hObject, eventdata, handles)
% hObject    handle to analizzabutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
index = get(handles.imgpopmenu,'Value');
imgs = get(handles.imgpopmenu,'String');
imgName = imgs{index};
result = main(imgName)



% --- Executes on selection change in imgpopmenu.
function imgpopmenu_Callback(hObject, eventdata, handles)
% hObject    handle to imgpopmenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns imgpopmenu contents as cell array
%        contents{get(hObject,'Value')} returns selected item from imgpopmenu


% --- Executes during object creation, after setting all properties.
function imgpopmenu_CreateFcn(hObject, eventdata, handles)
% hObject    handle to imgpopmenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% Progetto ESI 1 - Analisi di difetti di tessiture
% Robert Octavian Timofte - VR429581
% Emanuele Feola - VR437205
% Giacomo Mirandola - VR429611

function findDefects = main(img)

% Utilizzare queste righe per analizzare tutte le immagini, bisogna
% togliere il commento dall'end presente nell'ultima riga dello script

%Images = dir('img/*.jpg');
%for file=1:length(Images)
image = strcat('img/', img);
image = strcat(image, '.jpg')
A = rgb2gray(imread(image));

%A = rgb2gray(imread('img/img1.jpg'));
[R,C]=size(A);

% Definisco una serie di pattern, tutti quadrati 14x14.
% I pattern devono rappresentare aree senza difetto, un 20% dei pattern può
% anche rappresentare un difetto, idealmente è meglio non averne.
% Per il progetto posso anche usare una dimensione diversa e anche più
% pattern, in questo caso il bordo in altro a destra non è stato
% considerato a lezione, ma è stato aggiunto successivamente.
% size(pattern) = 14x14
pattern1 = A(1:14,1:14); 
pattern2 = A(2:15,2:15);
pattern3 = A(R-13:R,C-13:C);
pattern4 = A(R-14:R-1,C-14:C-1);
pattern5 = A(1:14,C-13:C);
pattern6 = A(2:15,C-14:C-1);

%figure;
%imagesc(A); axis image; colormap gray; hold on;
%rectangle('position',[1,1,14,14],'EdgeColor','r'); % pattern1
%rectangle('position',[2,2,14,14],'EdgeColor','g'); % pattern2
%rectangle('position',[C-13,R-13,14,14],'EdgeColor','b'); %pattern3
%rectangle('position',[C-14,R-14,14,14],'EdgeColor','c'); %pattern4
%rectangle('position',[1,R-13,14,14],'EdgeColor','m'); %pattern5
%rectangle('position',[2,R-14,14,14],'EdgeColor','k'); %pattern6

% Calcolo la xcorr-2D (normalizzata). Size = N+M-1
% Otteniamo dei coefficienti di correlazione compresi tra -1 e 1
c1 = normxcorr2(pattern1,A); % 525x525
c2 = normxcorr2(pattern2,A);
c3 = normxcorr2(pattern3,A);
c4 = normxcorr2(pattern4,A);
c5 = normxcorr2(pattern5,A);
c6 = normxcorr2(pattern6,A);

% From MATLAB Help:
% C = normxcorr2(TEMPLATE,A) computes the normalized cross-correlation of
%     matrices TEMPLATE and A. The matrix A must be larger than the matrix
%     TEMPLATE for the normalization to be meaningful. The values of TEMPLATE
%     cannot all be the same. The resulting matrix C contains correlation
%     coefficients and its values may range from -1.0 to 1.0.

c = (c1+c2+c3+c4+c5+c6)/6; % calcolo media (525x525)
c = c(13:end-13,13:end-13); % elimino il bordo creato dal padding, size(pattern)-1
%figure, surf(abs(c)), shading flat
%figure, imagesc(abs(c)), colorbar
c=abs(c);

% utilizzo m come soglia per fare la maschera, non funziona in tutti i casi
% però è già qualcosa
m = mean(c(:));
[I,J] = size(c);

% si può utilizzare al posto del comando mean
%m = 0; % valore che contiene la media di tutti i valori in c
%for i=1:I
%    for j=1:J
%        m = m + c(i,j);
%    end
%end
%m = m/(I*J); 
             
% selezioniamo una serie di valori che hanno cross-correlazione inferiore
% ad una soglia, otteniamo una maschera che contiene valori 1 o 0 in base
% alla condizione imposta
mask = c<m; % per il progetto bisogna trovare un valore ideale in automatico
%figure, imagesc(mask)

% NB: un difetto è rappresentato da più punti attaccati che hanno c minore
% della soglia imposta, potrebbero comunque esserci punti isolati che hanno
% valore di correlazione minore della soglia, quindi come prossimo passo si
% effettua un'operazione di pulizia tramite imopen

% crea un disco con R = 3, serve per eliminare punti della maschera che non
% rappresentano un difetto ma hanno comunque un valore di correlazione
% più basso della soglia imposta

% passiamo il disco sull'immagine facendo prima un'erosione, andando a
% togliere le aree che non devono rientrare nella maschera finale, poi
% faccio una dilatazione in modo da prendere solo le zone più compatte
% invece di punti isolati

% anche la dimensione del disco può influenzare il risultato, un disco
% troppo grande potrebbe erodere troppa informazione
se = strel('disk',3);
mask2 = imopen(mask,se);
%figure, imagesc(mask2);

% Nota per IMOPEN = Perform morphological opening.
% The opening operation erodes an image and then dilates the eroded image,
% using the same structuring element for both operations.
% Morphological opening is useful for removing small objects from an image
% while preserving the shape and size of larger objects in the image.

A=A(6:end-7,6:end-7); % Passo da 512x512 a 500x500, togliamo l'effetto bordo
A1 = A;
A1(mask2)=255;
Af=cat(3,A1,A,A);
figure;
imshowpair(A,Af,'montage')

end


